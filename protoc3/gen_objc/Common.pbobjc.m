// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - CommonRoot

@implementation CommonRoot

@end

#pragma mark - CommonRoot_FileDescriptor

static GPBFileDescriptor *CommonRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.xiang.proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum CardType

GPBEnumDescriptor *CardType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Once\000Month\000Quarter\000";
    static const int32_t values[] = {
        CardType_Once,
        CardType_Month,
        CardType_Quarter,
    };
    static const char *extraTextFormatInfo = "\003\000\004\000\001\005\000\002\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CardType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CardType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CardType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CardType_Once:
    case CardType_Month:
    case CardType_Quarter:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EquipmentType

GPBEnumDescriptor *EquipmentType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "PaoBuJi\000LinYuFang\000";
    static const int32_t values[] = {
        EquipmentType_PaoBuJi,
        EquipmentType_LinYuFang,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EquipmentType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EquipmentType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EquipmentType_IsValidValue(int32_t value__) {
  switch (value__) {
    case EquipmentType_PaoBuJi:
    case EquipmentType_LinYuFang:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Sex

GPBEnumDescriptor *Sex_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Male\000Female\000";
    static const int32_t values[] = {
        Sex_Male,
        Sex_Female,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Sex)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Sex_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Sex_IsValidValue(int32_t value__) {
  switch (value__) {
    case Sex_Male:
    case Sex_Female:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RequestCommon

@implementation RequestCommon

@dynamic userid;
@dynamic userkey;
@dynamic cmdid;
@dynamic timestamp;
@dynamic version;
@dynamic platform;

typedef struct RequestCommon__storage_ {
  uint32_t _has_storage_[1];
  int32_t userid;
  int32_t cmdid;
  int32_t platform;
  NSString *userkey;
  NSString *version;
  int64_t timestamp;
} RequestCommon__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userid",
        .dataTypeSpecific.className = NULL,
        .number = RequestCommon_FieldNumber_Userid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestCommon__storage_, userid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userkey",
        .dataTypeSpecific.className = NULL,
        .number = RequestCommon_FieldNumber_Userkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestCommon__storage_, userkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cmdid",
        .dataTypeSpecific.className = NULL,
        .number = RequestCommon_FieldNumber_Cmdid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestCommon__storage_, cmdid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = RequestCommon_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RequestCommon__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = RequestCommon_FieldNumber_Version,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RequestCommon__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platform",
        .dataTypeSpecific.className = NULL,
        .number = RequestCommon_FieldNumber_Platform,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RequestCommon__storage_, platform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestCommon class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestCommon__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseCommon

@implementation ResponseCommon

@dynamic code;
@dynamic message;
@dynamic cmdid;
@dynamic timestamp;
@dynamic userid;

typedef struct ResponseCommon__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  int32_t cmdid;
  int32_t userid;
  NSString *message;
  int64_t timestamp;
} ResponseCommon__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = ResponseCommon_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseCommon__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = ResponseCommon_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseCommon__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cmdid",
        .dataTypeSpecific.className = NULL,
        .number = ResponseCommon_FieldNumber_Cmdid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResponseCommon__storage_, cmdid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = ResponseCommon_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResponseCommon__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userid",
        .dataTypeSpecific.className = NULL,
        .number = ResponseCommon_FieldNumber_Userid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ResponseCommon__storage_, userid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseCommon class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseCommon__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Trend

@implementation Trend

@dynamic id_p;
@dynamic hasBriefUser, briefUser;
@dynamic createTime;
@dynamic gymId;
@dynamic gymName;
@dynamic content;
@dynamic imgsArray, imgsArray_Count;
@dynamic likeCount;
@dynamic commentCount;
@dynamic isLiked;

typedef struct Trend__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t gymId;
  int32_t likeCount;
  int32_t commentCount;
  BriefUser *briefUser;
  NSString *gymName;
  NSString *content;
  NSMutableArray *imgsArray;
  int64_t createTime;
} Trend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Trend_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Trend__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "briefUser",
        .dataTypeSpecific.className = GPBStringifySymbol(BriefUser),
        .number = Trend_FieldNumber_BriefUser,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Trend__storage_, briefUser),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = Trend_FieldNumber_CreateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Trend__storage_, createTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gymId",
        .dataTypeSpecific.className = NULL,
        .number = Trend_FieldNumber_GymId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Trend__storage_, gymId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gymName",
        .dataTypeSpecific.className = NULL,
        .number = Trend_FieldNumber_GymName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Trend__storage_, gymName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = Trend_FieldNumber_Content,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Trend__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgsArray",
        .dataTypeSpecific.className = NULL,
        .number = Trend_FieldNumber_ImgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Trend__storage_, imgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "likeCount",
        .dataTypeSpecific.className = NULL,
        .number = Trend_FieldNumber_LikeCount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Trend__storage_, likeCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentCount",
        .dataTypeSpecific.className = NULL,
        .number = Trend_FieldNumber_CommentCount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Trend__storage_, commentCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isLiked",
        .dataTypeSpecific.className = NULL,
        .number = Trend_FieldNumber_IsLiked,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Trend class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Trend__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\002\t\000\003\n\000\004\005\000\005\007\000\010\t\000\t\014\000\n\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Banner

@implementation Banner

@dynamic id_p;
@dynamic coverURL;
@dynamic type;
@dynamic webURL;
@dynamic trendId;
@dynamic userId;

typedef struct Banner__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  Banner_BannerType type;
  int32_t trendId;
  int32_t userId;
  NSString *coverURL;
  NSString *webURL;
} Banner__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Banner_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Banner__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "coverURL",
        .dataTypeSpecific.className = NULL,
        .number = Banner_FieldNumber_CoverURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Banner__storage_, coverURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Banner_BannerType_EnumDescriptor,
        .number = Banner_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Banner__storage_, type),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "webURL",
        .dataTypeSpecific.className = NULL,
        .number = Banner_FieldNumber_WebURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Banner__storage_, webURL),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "trendId",
        .dataTypeSpecific.className = NULL,
        .number = Banner_FieldNumber_TrendId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Banner__storage_, trendId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = Banner_FieldNumber_UserId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Banner__storage_, userId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Banner class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Banner__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\006!!\000\004\004!!\000\005\007\000\006\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Banner_Type_RawValue(Banner *message) {
  GPBDescriptor *descriptor = [Banner descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Banner_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetBanner_Type_RawValue(Banner *message, int32_t value) {
  GPBDescriptor *descriptor = [Banner descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Banner_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Banner_BannerType

GPBEnumDescriptor *Banner_BannerType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "URL\000Trend\000User\000";
    static const int32_t values[] = {
        Banner_BannerType_URL,
        Banner_BannerType_Trend,
        Banner_BannerType_User,
    };
    static const char *extraTextFormatInfo = "\001\000\003\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Banner_BannerType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Banner_BannerType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Banner_BannerType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Banner_BannerType_URL:
    case Banner_BannerType_Trend:
    case Banner_BannerType_User:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BriefUser

@implementation BriefUser

@dynamic userId;
@dynamic userName;
@dynamic userAvatar;

typedef struct BriefUser__storage_ {
  uint32_t _has_storage_[1];
  int32_t userId;
  NSString *userName;
  NSString *userAvatar;
} BriefUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = BriefUser_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BriefUser__storage_, userId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = BriefUser_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BriefUser__storage_, userName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userAvatar",
        .dataTypeSpecific.className = NULL,
        .number = BriefUser_FieldNumber_UserAvatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BriefUser__storage_, userAvatar),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BriefUser class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BriefUser__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\006\000\002\010\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BriefGym

@implementation BriefGym

@dynamic id_p;
@dynamic gymName;
@dynamic place;
@dynamic gymAvatar;
@dynamic latitude;
@dynamic longitude;
@dynamic gymIntro;

typedef struct BriefGym__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  float latitude;
  float longitude;
  NSString *gymName;
  NSString *place;
  NSString *gymIntro;
  NSString *gymAvatar;
} BriefGym__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = BriefGym_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BriefGym__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gymName",
        .dataTypeSpecific.className = NULL,
        .number = BriefGym_FieldNumber_GymName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BriefGym__storage_, gymName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "place",
        .dataTypeSpecific.className = NULL,
        .number = BriefGym_FieldNumber_Place,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BriefGym__storage_, place),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = BriefGym_FieldNumber_Latitude,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BriefGym__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = BriefGym_FieldNumber_Longitude,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BriefGym__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "gymIntro",
        .dataTypeSpecific.className = NULL,
        .number = BriefGym_FieldNumber_GymIntro,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BriefGym__storage_, gymIntro),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gymAvatar",
        .dataTypeSpecific.className = NULL,
        .number = BriefGym_FieldNumber_GymAvatar,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BriefGym__storage_, gymAvatar),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BriefGym class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BriefGym__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\007\000\007\010\000\010\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DetailGym

@implementation DetailGym

@dynamic hasBriefGym, briefGym;
@dynamic eqm;
@dynamic courses;
@dynamic gymCards;

typedef struct DetailGym__storage_ {
  uint32_t _has_storage_[1];
  BriefGym *briefGym;
  NSString *eqm;
  NSString *courses;
  NSString *gymCards;
} DetailGym__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "briefGym",
        .dataTypeSpecific.className = GPBStringifySymbol(BriefGym),
        .number = DetailGym_FieldNumber_BriefGym,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DetailGym__storage_, briefGym),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eqm",
        .dataTypeSpecific.className = NULL,
        .number = DetailGym_FieldNumber_Eqm,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DetailGym__storage_, eqm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "courses",
        .dataTypeSpecific.className = NULL,
        .number = DetailGym_FieldNumber_Courses,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DetailGym__storage_, courses),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gymCards",
        .dataTypeSpecific.className = NULL,
        .number = DetailGym_FieldNumber_GymCards,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DetailGym__storage_, gymCards),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DetailGym class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DetailGym__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Equipment

@implementation Equipment

@dynamic name;
@dynamic count;
@dynamic equipmentType;

typedef struct Equipment__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  EquipmentType equipmentType;
  NSString *name;
} Equipment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Equipment_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Equipment__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = Equipment_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Equipment__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "equipmentType",
        .dataTypeSpecific.enumDescFunc = EquipmentType_EnumDescriptor,
        .number = Equipment_FieldNumber_EquipmentType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Equipment__storage_, equipmentType),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Equipment class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Equipment__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Equipment_EquipmentType_RawValue(Equipment *message) {
  GPBDescriptor *descriptor = [Equipment descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Equipment_FieldNumber_EquipmentType];
  return GPBGetMessageInt32Field(message, field);
}

void SetEquipment_EquipmentType_RawValue(Equipment *message, int32_t value) {
  GPBDescriptor *descriptor = [Equipment descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Equipment_FieldNumber_EquipmentType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Course

@implementation Course

@dynamic name;
@dynamic week;
@dynamic hasCourseTime, courseTime;

typedef struct Course__storage_ {
  uint32_t _has_storage_[1];
  int32_t week;
  NSString *name;
  CourseTime *courseTime;
} Course__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Course_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Course__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "week",
        .dataTypeSpecific.className = NULL,
        .number = Course_FieldNumber_Week,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Course__storage_, week),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "courseTime",
        .dataTypeSpecific.className = GPBStringifySymbol(CourseTime),
        .number = Course_FieldNumber_CourseTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Course__storage_, courseTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Course class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Course__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CourseTime

@implementation CourseTime

@dynamic fromHour;
@dynamic fromMinite;
@dynamic toHour;
@dynamic toMinite;

typedef struct CourseTime__storage_ {
  uint32_t _has_storage_[1];
  int32_t fromHour;
  int32_t fromMinite;
  int32_t toHour;
  int32_t toMinite;
} CourseTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromHour",
        .dataTypeSpecific.className = NULL,
        .number = CourseTime_FieldNumber_FromHour,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CourseTime__storage_, fromHour),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fromMinite",
        .dataTypeSpecific.className = NULL,
        .number = CourseTime_FieldNumber_FromMinite,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CourseTime__storage_, fromMinite),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "toHour",
        .dataTypeSpecific.className = NULL,
        .number = CourseTime_FieldNumber_ToHour,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CourseTime__storage_, toHour),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "toMinite",
        .dataTypeSpecific.className = NULL,
        .number = CourseTime_FieldNumber_ToMinite,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CourseTime__storage_, toMinite),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CourseTime class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CourseTime__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\010\000\002\n\000\003\006\000\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GymCard

@implementation GymCard

@dynamic cardType;
@dynamic price;

typedef struct GymCard__storage_ {
  uint32_t _has_storage_[1];
  CardType cardType;
  float price;
} GymCard__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cardType",
        .dataTypeSpecific.enumDescFunc = CardType_EnumDescriptor,
        .number = GymCard_FieldNumber_CardType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GymCard__storage_, cardType),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = GymCard_FieldNumber_Price,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GymCard__storage_, price),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GymCard class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GymCard__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GymCard_CardType_RawValue(GymCard *message) {
  GPBDescriptor *descriptor = [GymCard descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GymCard_FieldNumber_CardType];
  return GPBGetMessageInt32Field(message, field);
}

void SetGymCard_CardType_RawValue(GymCard *message, int32_t value) {
  GPBDescriptor *descriptor = [GymCard descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GymCard_FieldNumber_CardType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CommentMessage

@implementation CommentMessage

@dynamic messageId;
@dynamic messageContent;
@dynamic avatar;
@dynamic createTime;
@dynamic trendId;

typedef struct CommentMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t messageId;
  int32_t trendId;
  NSString *messageContent;
  NSString *avatar;
  int64_t createTime;
} CommentMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = CommentMessage_FieldNumber_MessageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommentMessage__storage_, messageId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageContent",
        .dataTypeSpecific.className = NULL,
        .number = CommentMessage_FieldNumber_MessageContent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CommentMessage__storage_, messageContent),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = CommentMessage_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CommentMessage__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = CommentMessage_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CommentMessage__storage_, createTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "trendId",
        .dataTypeSpecific.className = NULL,
        .number = CommentMessage_FieldNumber_TrendId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CommentMessage__storage_, trendId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommentMessage class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommentMessage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\t\000\002\016\000\004\n\000\005\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Comment

@implementation Comment

@dynamic hasBriefUser, briefUser;
@dynamic commentId;
@dynamic commentContent;
@dynamic trendId;
@dynamic toUserid;
@dynamic toUserName;
@dynamic createTime;
@dynamic gymName;

typedef struct Comment__storage_ {
  uint32_t _has_storage_[1];
  int32_t commentId;
  int32_t trendId;
  int32_t toUserid;
  BriefUser *briefUser;
  NSString *commentContent;
  NSString *toUserName;
  NSString *gymName;
  int64_t createTime;
} Comment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "briefUser",
        .dataTypeSpecific.className = GPBStringifySymbol(BriefUser),
        .number = Comment_FieldNumber_BriefUser,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Comment__storage_, briefUser),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "commentId",
        .dataTypeSpecific.className = NULL,
        .number = Comment_FieldNumber_CommentId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Comment__storage_, commentId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "commentContent",
        .dataTypeSpecific.className = NULL,
        .number = Comment_FieldNumber_CommentContent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Comment__storage_, commentContent),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "trendId",
        .dataTypeSpecific.className = NULL,
        .number = Comment_FieldNumber_TrendId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Comment__storage_, trendId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "toUserid",
        .dataTypeSpecific.className = NULL,
        .number = Comment_FieldNumber_ToUserid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Comment__storage_, toUserid),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "toUserName",
        .dataTypeSpecific.className = NULL,
        .number = Comment_FieldNumber_ToUserName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Comment__storage_, toUserName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = Comment_FieldNumber_CreateTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Comment__storage_, createTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gymName",
        .dataTypeSpecific.className = NULL,
        .number = Comment_FieldNumber_GymName,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Comment__storage_, gymName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Comment class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Comment__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001\t\000\002\t\000\003\016\000\004\007\000\005\010\000\006\n\000\007\n\000\010\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TrendBriefMessage

@implementation TrendBriefMessage

@dynamic lastAvatar;
@dynamic count;

typedef struct TrendBriefMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  NSString *lastAvatar;
} TrendBriefMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastAvatar",
        .dataTypeSpecific.className = NULL,
        .number = TrendBriefMessage_FieldNumber_LastAvatar,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TrendBriefMessage__storage_, lastAvatar),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = TrendBriefMessage_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TrendBriefMessage__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TrendBriefMessage class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TrendBriefMessage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DetailUser

@implementation DetailUser

@dynamic userId;
@dynamic userName;
@dynamic userAvatar;
@dynamic sex;
@dynamic sign;
@dynamic trendsArray, trendsArray_Count;
@dynamic isFollowed;
@dynamic guanzhuCount;
@dynamic fensiCount;
@dynamic trendCount;
@dynamic trendMaxCountPerPage;

typedef struct DetailUser__storage_ {
  uint32_t _has_storage_[1];
  int32_t userId;
  Sex sex;
  int32_t guanzhuCount;
  int32_t fensiCount;
  int32_t trendCount;
  int32_t trendMaxCountPerPage;
  NSString *userName;
  NSString *userAvatar;
  NSString *sign;
  NSMutableArray *trendsArray;
} DetailUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = DetailUser_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DetailUser__storage_, userId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = DetailUser_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DetailUser__storage_, userName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userAvatar",
        .dataTypeSpecific.className = NULL,
        .number = DetailUser_FieldNumber_UserAvatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DetailUser__storage_, userAvatar),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.enumDescFunc = Sex_EnumDescriptor,
        .number = DetailUser_FieldNumber_Sex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DetailUser__storage_, sex),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = DetailUser_FieldNumber_Sign,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DetailUser__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "trendsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Trend),
        .number = DetailUser_FieldNumber_TrendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DetailUser__storage_, trendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isFollowed",
        .dataTypeSpecific.className = NULL,
        .number = DetailUser_FieldNumber_IsFollowed,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "guanzhuCount",
        .dataTypeSpecific.className = NULL,
        .number = DetailUser_FieldNumber_GuanzhuCount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DetailUser__storage_, guanzhuCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fensiCount",
        .dataTypeSpecific.className = NULL,
        .number = DetailUser_FieldNumber_FensiCount,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DetailUser__storage_, fensiCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trendCount",
        .dataTypeSpecific.className = NULL,
        .number = DetailUser_FieldNumber_TrendCount,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DetailUser__storage_, trendCount),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "trendMaxCountPerPage",
        .dataTypeSpecific.className = NULL,
        .number = DetailUser_FieldNumber_TrendMaxCountPerPage,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(DetailUser__storage_, trendMaxCountPerPage),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DetailUser class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DetailUser__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001\006\000\002\010\000\003\n\000\007\n\000\010\014\000\t\n\000\n\n\000\013\024\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DetailUser_Sex_RawValue(DetailUser *message) {
  GPBDescriptor *descriptor = [DetailUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DetailUser_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetDetailUser_Sex_RawValue(DetailUser *message, int32_t value) {
  GPBDescriptor *descriptor = [DetailUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DetailUser_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - SearchedUser

@implementation SearchedUser

@dynamic userId;
@dynamic userName;
@dynamic userAvatar;
@dynamic sign;
@dynamic imagesArray, imagesArray_Count;

typedef struct SearchedUser__storage_ {
  uint32_t _has_storage_[1];
  int32_t userId;
  NSString *userName;
  NSString *userAvatar;
  NSString *sign;
  NSMutableArray *imagesArray;
} SearchedUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = SearchedUser_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchedUser__storage_, userId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = SearchedUser_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SearchedUser__storage_, userName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userAvatar",
        .dataTypeSpecific.className = NULL,
        .number = SearchedUser_FieldNumber_UserAvatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SearchedUser__storage_, userAvatar),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = SearchedUser_FieldNumber_Sign,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SearchedUser__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imagesArray",
        .dataTypeSpecific.className = NULL,
        .number = SearchedUser_FieldNumber_ImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SearchedUser__storage_, imagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchedUser class]
                                     rootClass:[CommonRoot class]
                                          file:CommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchedUser__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\006\000\002\010\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
